schema {
  query: Query
}

interface Error {
  message: String!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type Category implements Node {
  id: ID!
  categoryName: String!
  description: String
  picture: [Byte!]
  products: [Product!]!
}

type Customer implements Node {
  id: ID!
  companyName: String!
  contactName: String
  contactTitle: String
  address: String
  city: String
  region: String
  postalCode: String
  country: String
  phone: String
  fax: String
  orders: [Order!]!
  demographics: [CustomerDemographic!]!
}

type CustomerDemographic {
  customerTypeId: String!
  customerDesc: String
  customers: [Customer!]!
}

"A connection to a list of items."
type CustomersConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [CustomersEdge!]
  "A flattened list of the nodes."
  nodes: [Customer!]
}

"An edge in a connection."
type CustomersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Customer!
}

type Employee implements Node {
  id: ID!
  directReports: [Employee!]! @cost(weight: "10")
  lastName: String!
  firstName: String!
  title: String
  titleOfCourtesy: String
  birthDate: LocalDate
  hireDate: LocalDate
  address: String
  city: String
  region: String
  postalCode: String
  country: String
  homePhone: String
  extension: String
  photo: [Byte!]
  notes: String
  reportsTo: Short
  photoPath: String
  manager: Employee
  orders: [Order!]!
  territories: [Territory!]!
}

"A connection to a list of items."
type EmployeesConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [EmployeesEdge!]
  "A flattened list of the nodes."
  nodes: [Employee!]
}

"An edge in a connection."
type EmployeesEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Employee!
}

type Order implements Node {
  id: ID!
  products: [Product!] @cost(weight: "10")
  shipper: Shipper @cost(weight: "10")
  customerId: String
  employeeId: Short
  orderDate: LocalDate
  requiredDate: LocalDate
  shippedDate: LocalDate
  shipVia: Short
  freight: Float
  shipName: String
  shipAddress: String
  shipCity: String
  shipRegion: String
  shipPostalCode: String
  shipCountry: String
  customer: Customer
  employee: Employee
  orderDetails: [OrderDetail!]!
}

type OrderDetail {
  product: Product @cost(weight: "10")
  order: Order @cost(weight: "10")
  unitPrice: Float!
  quantity: Short!
  discount: Float!
}

"A connection to a list of items."
type OrdersConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [OrdersEdge!]
  "A flattened list of the nodes."
  nodes: [Order!]
}

"An edge in a connection."
type OrdersEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Order!
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

type Product implements Node {
  id: ID!
  category: Category @cost(weight: "10")
  supplier: Supplier @cost(weight: "10")
  orderDetails: [OrderDetail!] @cost(weight: "10")
  productName: String!
  supplierId: Short
  categoryId: Short
  quantityPerUnit: String
  unitPrice: Float
  unitsInStock: Short
  unitsOnOrder: Short
  reorderLevel: Short
  discontinued: Int!
}

"A connection to a list of items."
type ProductsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [ProductsEdge!]
  "A flattened list of the nodes."
  nodes: [Product!]
}

"An edge in a connection."
type ProductsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Product!
}

type Query {
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node @cost(weight: "10")
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]! @cost(weight: "10")
  orders(
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the last _n_ elements from the list."
    last: Int
    "Returns the elements in the list that come before the specified cursor."
    before: String
    where: OrderFilterInput @cost(weight: "10")
    order: [OrderSortInput!] @cost(weight: "10")
  ): OrdersConnection
    @listSize(
      assumedSize: 50
      slicingArguments: ["first", "last"]
      slicingArgumentDefaultValue: 10
      sizedFields: ["edges", "nodes"]
      requireOneSlicingArgument: false
    )
    @cost(weight: "10")
  products(
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the last _n_ elements from the list."
    last: Int
    "Returns the elements in the list that come before the specified cursor."
    before: String
    where: ProductFilterInput @cost(weight: "10")
    order: [ProductSortInput!] @cost(weight: "10")
  ): ProductsConnection
    @listSize(
      assumedSize: 50
      slicingArguments: ["first", "last"]
      slicingArgumentDefaultValue: 10
      sizedFields: ["edges", "nodes"]
      requireOneSlicingArgument: false
    )
    @cost(weight: "10")
  employees(
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the last _n_ elements from the list."
    last: Int
    "Returns the elements in the list that come before the specified cursor."
    before: String
    where: EmployeeFilterInput @cost(weight: "10")
    order: [EmployeeSortInput!] @cost(weight: "10")
  ): EmployeesConnection
    @listSize(
      assumedSize: 50
      slicingArguments: ["first", "last"]
      slicingArgumentDefaultValue: 10
      sizedFields: ["edges", "nodes"]
      requireOneSlicingArgument: false
    )
    @cost(weight: "10")
  customers(
    "Returns the first _n_ elements from the list."
    first: Int
    "Returns the elements in the list that come after the specified cursor."
    after: String
    "Returns the last _n_ elements from the list."
    last: Int
    "Returns the elements in the list that come before the specified cursor."
    before: String
    where: CustomerFilterInput @cost(weight: "10")
    order: [CustomerSortInput!] @cost(weight: "10")
  ): CustomersConnection
    @listSize(
      assumedSize: 50
      slicingArguments: ["first", "last"]
      slicingArgumentDefaultValue: 10
      sizedFields: ["edges", "nodes"]
      requireOneSlicingArgument: false
    )
    @cost(weight: "10")
}

type Region {
  regionId: Short!
  regionDescription: String!
  territories: [Territory!]!
}

type Shipper implements Node {
  id: ID!
  companyName: String!
  phone: String
  orders: [Order!]!
}

type Supplier implements Node {
  id: ID!
  companyName: String!
  contactName: String
  contactTitle: String
  address: String
  city: String
  region: String
  postalCode: String
  country: String
  phone: String
  fax: String
  homepage: String
  products: [Product!]!
}

type Territory {
  territoryId: String!
  territoryDescription: String!
  regionId: Short!
  region: Region!
  employees: [Employee!]!
}

input ByteOperationFilterInput {
  eq: Byte @cost(weight: "10")
  neq: Byte @cost(weight: "10")
  in: [Byte] @cost(weight: "10")
  nin: [Byte] @cost(weight: "10")
  gt: Byte @cost(weight: "10")
  ngt: Byte @cost(weight: "10")
  gte: Byte @cost(weight: "10")
  ngte: Byte @cost(weight: "10")
  lt: Byte @cost(weight: "10")
  nlt: Byte @cost(weight: "10")
  lte: Byte @cost(weight: "10")
  nlte: Byte @cost(weight: "10")
}

input CategoryFilterInput {
  and: [CategoryFilterInput!]
  or: [CategoryFilterInput!]
  categoryId: ShortOperationFilterInput
  categoryName: StringOperationFilterInput
  description: StringOperationFilterInput
  picture: ListByteOperationFilterInput
  products: ListFilterInputTypeOfProductFilterInput
}

input CategorySortInput {
  categoryId: SortEnumType @cost(weight: "10")
  categoryName: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
}

input CustomerDemographicFilterInput {
  and: [CustomerDemographicFilterInput!]
  or: [CustomerDemographicFilterInput!]
  customerTypeId: StringOperationFilterInput
  customerDesc: StringOperationFilterInput
  customers: ListFilterInputTypeOfCustomerFilterInput
}

input CustomerFilterInput {
  and: [CustomerFilterInput!]
  or: [CustomerFilterInput!]
  customerId: StringOperationFilterInput
  companyName: StringOperationFilterInput
  contactName: StringOperationFilterInput
  contactTitle: StringOperationFilterInput
  address: StringOperationFilterInput
  city: StringOperationFilterInput
  region: StringOperationFilterInput
  postalCode: StringOperationFilterInput
  country: StringOperationFilterInput
  phone: StringOperationFilterInput
  fax: StringOperationFilterInput
  orders: ListFilterInputTypeOfOrderFilterInput
  demographics: ListFilterInputTypeOfCustomerDemographicFilterInput
}

input CustomerSortInput {
  customerId: SortEnumType @cost(weight: "10")
  companyName: SortEnumType @cost(weight: "10")
  contactName: SortEnumType @cost(weight: "10")
  contactTitle: SortEnumType @cost(weight: "10")
  address: SortEnumType @cost(weight: "10")
  city: SortEnumType @cost(weight: "10")
  region: SortEnumType @cost(weight: "10")
  postalCode: SortEnumType @cost(weight: "10")
  country: SortEnumType @cost(weight: "10")
  phone: SortEnumType @cost(weight: "10")
  fax: SortEnumType @cost(weight: "10")
}

input EmployeeFilterInput {
  and: [EmployeeFilterInput!]
  or: [EmployeeFilterInput!]
  employeeId: ShortOperationFilterInput
  lastName: StringOperationFilterInput
  firstName: StringOperationFilterInput
  title: StringOperationFilterInput
  titleOfCourtesy: StringOperationFilterInput
  birthDate: LocalDateOperationFilterInput
  hireDate: LocalDateOperationFilterInput
  address: StringOperationFilterInput
  city: StringOperationFilterInput
  region: StringOperationFilterInput
  postalCode: StringOperationFilterInput
  country: StringOperationFilterInput
  homePhone: StringOperationFilterInput
  extension: StringOperationFilterInput
  photo: ListByteOperationFilterInput
  notes: StringOperationFilterInput
  reportsTo: ShortOperationFilterInput
  photoPath: StringOperationFilterInput
  manager: EmployeeFilterInput
  directReports: ListFilterInputTypeOfEmployeeFilterInput
  orders: ListFilterInputTypeOfOrderFilterInput
  territories: ListFilterInputTypeOfTerritoryFilterInput
}

input EmployeeSortInput {
  employeeId: SortEnumType @cost(weight: "10")
  lastName: SortEnumType @cost(weight: "10")
  firstName: SortEnumType @cost(weight: "10")
  title: SortEnumType @cost(weight: "10")
  titleOfCourtesy: SortEnumType @cost(weight: "10")
  birthDate: SortEnumType @cost(weight: "10")
  hireDate: SortEnumType @cost(weight: "10")
  address: SortEnumType @cost(weight: "10")
  city: SortEnumType @cost(weight: "10")
  region: SortEnumType @cost(weight: "10")
  postalCode: SortEnumType @cost(weight: "10")
  country: SortEnumType @cost(weight: "10")
  homePhone: SortEnumType @cost(weight: "10")
  extension: SortEnumType @cost(weight: "10")
  notes: SortEnumType @cost(weight: "10")
  reportsTo: SortEnumType @cost(weight: "10")
  photoPath: SortEnumType @cost(weight: "10")
  manager: EmployeeSortInput @cost(weight: "10")
}

input FloatOperationFilterInput {
  eq: Float @cost(weight: "10")
  neq: Float @cost(weight: "10")
  in: [Float] @cost(weight: "10")
  nin: [Float] @cost(weight: "10")
  gt: Float @cost(weight: "10")
  ngt: Float @cost(weight: "10")
  gte: Float @cost(weight: "10")
  ngte: Float @cost(weight: "10")
  lt: Float @cost(weight: "10")
  nlt: Float @cost(weight: "10")
  lte: Float @cost(weight: "10")
  nlte: Float @cost(weight: "10")
}

input IntOperationFilterInput {
  eq: Int @cost(weight: "10")
  neq: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  nin: [Int] @cost(weight: "10")
  gt: Int @cost(weight: "10")
  ngt: Int @cost(weight: "10")
  gte: Int @cost(weight: "10")
  ngte: Int @cost(weight: "10")
  lt: Int @cost(weight: "10")
  nlt: Int @cost(weight: "10")
  lte: Int @cost(weight: "10")
  nlte: Int @cost(weight: "10")
}

input ListByteOperationFilterInput {
  all: ByteOperationFilterInput @cost(weight: "10")
  none: ByteOperationFilterInput @cost(weight: "10")
  some: ByteOperationFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfCustomerDemographicFilterInput {
  all: CustomerDemographicFilterInput @cost(weight: "10")
  none: CustomerDemographicFilterInput @cost(weight: "10")
  some: CustomerDemographicFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfCustomerFilterInput {
  all: CustomerFilterInput @cost(weight: "10")
  none: CustomerFilterInput @cost(weight: "10")
  some: CustomerFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfEmployeeFilterInput {
  all: EmployeeFilterInput @cost(weight: "10")
  none: EmployeeFilterInput @cost(weight: "10")
  some: EmployeeFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfOrderDetailFilterInput {
  all: OrderDetailFilterInput @cost(weight: "10")
  none: OrderDetailFilterInput @cost(weight: "10")
  some: OrderDetailFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfOrderFilterInput {
  all: OrderFilterInput @cost(weight: "10")
  none: OrderFilterInput @cost(weight: "10")
  some: OrderFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfProductFilterInput {
  all: ProductFilterInput @cost(weight: "10")
  none: ProductFilterInput @cost(weight: "10")
  some: ProductFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfTerritoryFilterInput {
  all: TerritoryFilterInput @cost(weight: "10")
  none: TerritoryFilterInput @cost(weight: "10")
  some: TerritoryFilterInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input LocalDateOperationFilterInput {
  eq: LocalDate @cost(weight: "10")
  neq: LocalDate @cost(weight: "10")
  in: [LocalDate] @cost(weight: "10")
  nin: [LocalDate] @cost(weight: "10")
  gt: LocalDate @cost(weight: "10")
  ngt: LocalDate @cost(weight: "10")
  gte: LocalDate @cost(weight: "10")
  ngte: LocalDate @cost(weight: "10")
  lt: LocalDate @cost(weight: "10")
  nlt: LocalDate @cost(weight: "10")
  lte: LocalDate @cost(weight: "10")
  nlte: LocalDate @cost(weight: "10")
}

input OrderDetailFilterInput {
  and: [OrderDetailFilterInput!]
  or: [OrderDetailFilterInput!]
  orderId: ShortOperationFilterInput
  productId: ShortOperationFilterInput
  unitPrice: FloatOperationFilterInput
  quantity: ShortOperationFilterInput
  discount: FloatOperationFilterInput
  order: OrderFilterInput
  product: ProductFilterInput
}

input OrderFilterInput {
  and: [OrderFilterInput!]
  or: [OrderFilterInput!]
  orderId: ShortOperationFilterInput
  customerId: StringOperationFilterInput
  employeeId: ShortOperationFilterInput
  orderDate: LocalDateOperationFilterInput
  requiredDate: LocalDateOperationFilterInput
  shippedDate: LocalDateOperationFilterInput
  shipVia: ShortOperationFilterInput
  freight: FloatOperationFilterInput
  shipName: StringOperationFilterInput
  shipAddress: StringOperationFilterInput
  shipCity: StringOperationFilterInput
  shipRegion: StringOperationFilterInput
  shipPostalCode: StringOperationFilterInput
  shipCountry: StringOperationFilterInput
  customer: CustomerFilterInput
  employee: EmployeeFilterInput
  shipper: ShipperFilterInput
  orderDetails: ListFilterInputTypeOfOrderDetailFilterInput
}

input OrderSortInput {
  orderId: SortEnumType @cost(weight: "10")
  customerId: SortEnumType @cost(weight: "10")
  employeeId: SortEnumType @cost(weight: "10")
  orderDate: SortEnumType @cost(weight: "10")
  requiredDate: SortEnumType @cost(weight: "10")
  shippedDate: SortEnumType @cost(weight: "10")
  shipVia: SortEnumType @cost(weight: "10")
  freight: SortEnumType @cost(weight: "10")
  shipName: SortEnumType @cost(weight: "10")
  shipAddress: SortEnumType @cost(weight: "10")
  shipCity: SortEnumType @cost(weight: "10")
  shipRegion: SortEnumType @cost(weight: "10")
  shipPostalCode: SortEnumType @cost(weight: "10")
  shipCountry: SortEnumType @cost(weight: "10")
  customer: CustomerSortInput @cost(weight: "10")
  employee: EmployeeSortInput @cost(weight: "10")
  shipper: ShipperSortInput @cost(weight: "10")
}

input ProductFilterInput {
  and: [ProductFilterInput!]
  or: [ProductFilterInput!]
  productId: ShortOperationFilterInput
  productName: StringOperationFilterInput
  supplierId: ShortOperationFilterInput
  categoryId: ShortOperationFilterInput
  quantityPerUnit: StringOperationFilterInput
  unitPrice: FloatOperationFilterInput
  unitsInStock: ShortOperationFilterInput
  unitsOnOrder: ShortOperationFilterInput
  reorderLevel: ShortOperationFilterInput
  discontinued: IntOperationFilterInput
  category: CategoryFilterInput
  supplier: SupplierFilterInput
  orderDetails: ListFilterInputTypeOfOrderDetailFilterInput
}

input ProductSortInput {
  productId: SortEnumType @cost(weight: "10")
  productName: SortEnumType @cost(weight: "10")
  supplierId: SortEnumType @cost(weight: "10")
  categoryId: SortEnumType @cost(weight: "10")
  quantityPerUnit: SortEnumType @cost(weight: "10")
  unitPrice: SortEnumType @cost(weight: "10")
  unitsInStock: SortEnumType @cost(weight: "10")
  unitsOnOrder: SortEnumType @cost(weight: "10")
  reorderLevel: SortEnumType @cost(weight: "10")
  discontinued: SortEnumType @cost(weight: "10")
  category: CategorySortInput @cost(weight: "10")
  supplier: SupplierSortInput @cost(weight: "10")
}

input RegionFilterInput {
  and: [RegionFilterInput!]
  or: [RegionFilterInput!]
  regionId: ShortOperationFilterInput
  regionDescription: StringOperationFilterInput
  territories: ListFilterInputTypeOfTerritoryFilterInput
}

input ShipperFilterInput {
  and: [ShipperFilterInput!]
  or: [ShipperFilterInput!]
  shipperId: ShortOperationFilterInput
  companyName: StringOperationFilterInput
  phone: StringOperationFilterInput
  orders: ListFilterInputTypeOfOrderFilterInput
}

input ShipperSortInput {
  shipperId: SortEnumType @cost(weight: "10")
  companyName: SortEnumType @cost(weight: "10")
  phone: SortEnumType @cost(weight: "10")
}

input ShortOperationFilterInput {
  eq: Short @cost(weight: "10")
  neq: Short @cost(weight: "10")
  in: [Short] @cost(weight: "10")
  nin: [Short] @cost(weight: "10")
  gt: Short @cost(weight: "10")
  ngt: Short @cost(weight: "10")
  gte: Short @cost(weight: "10")
  ngte: Short @cost(weight: "10")
  lt: Short @cost(weight: "10")
  nlt: Short @cost(weight: "10")
  lte: Short @cost(weight: "10")
  nlte: Short @cost(weight: "10")
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String @cost(weight: "10")
  neq: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  ncontains: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  nin: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  nstartsWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  nendsWith: String @cost(weight: "20")
}

input SupplierFilterInput {
  and: [SupplierFilterInput!]
  or: [SupplierFilterInput!]
  supplierId: ShortOperationFilterInput
  companyName: StringOperationFilterInput
  contactName: StringOperationFilterInput
  contactTitle: StringOperationFilterInput
  address: StringOperationFilterInput
  city: StringOperationFilterInput
  region: StringOperationFilterInput
  postalCode: StringOperationFilterInput
  country: StringOperationFilterInput
  phone: StringOperationFilterInput
  fax: StringOperationFilterInput
  homepage: StringOperationFilterInput
  products: ListFilterInputTypeOfProductFilterInput
}

input SupplierSortInput {
  supplierId: SortEnumType @cost(weight: "10")
  companyName: SortEnumType @cost(weight: "10")
  contactName: SortEnumType @cost(weight: "10")
  contactTitle: SortEnumType @cost(weight: "10")
  address: SortEnumType @cost(weight: "10")
  city: SortEnumType @cost(weight: "10")
  region: SortEnumType @cost(weight: "10")
  postalCode: SortEnumType @cost(weight: "10")
  country: SortEnumType @cost(weight: "10")
  phone: SortEnumType @cost(weight: "10")
  fax: SortEnumType @cost(weight: "10")
  homepage: SortEnumType @cost(weight: "10")
}

input TerritoryFilterInput {
  and: [TerritoryFilterInput!]
  or: [TerritoryFilterInput!]
  territoryId: StringOperationFilterInput
  territoryDescription: StringOperationFilterInput
  regionId: ShortOperationFilterInput
  region: RegionFilterInput
  employees: ListFilterInputTypeOfEmployeeFilterInput
}

enum SortEnumType {
  ASC
  DESC
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
  "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
  weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize(
  "The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field."
  assumedSize: Int
  "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments."
  slicingArguments: [String!]
  "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query."
  slicingArgumentDefaultValue: Int
  "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields."
  sizedFields: [String!]
  "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error."
  requireOneSlicingArgument: Boolean! = true
) on FIELD_DEFINITION

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

"The `LocalDate` scalar type represents a ISO date string, represented as UTF-8 character sequences YYYY-MM-DD. The scalar follows the specification defined in RFC3339"
scalar LocalDate

"The `Short` scalar type represents non-fractional signed whole 16-bit numeric values. Short can represent values between -(2^15) and 2^15 - 1."
scalar Short
